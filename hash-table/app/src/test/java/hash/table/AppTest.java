/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package hash.table;

import org.junit.Test;
import repeatedWord.RepeatedWord;
import treeIntersection.TreeIntersection;
import trees.BinaryTree;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import static org.junit.Assert.*;

public class AppTest {
    @Test public void appHasAGreeting() {
        App classUnderTest = new App();
        assertNotNull("app should have a greeting", classUnderTest.getGreeting());
    }

    @Test public void testHashTableAddingKeyValue() {
        Hashtable<Integer> idsTable = new Hashtable();
        idsTable.add("Mohammad",11);
        boolean output = idsTable.contains("Mohammad");
        assertTrue(output);
    }

    @Test public void testHashTableRetrievingValueBasedOnKey() {
        Hashtable<Integer> idsTable = new Hashtable();
        idsTable.add("Mohammad",11);
        int output = idsTable.get("Mohammad");
        assertEquals(11, output);
    }

    @Test public void testHashTableRetrievingNullForNotExistKey() {
        Hashtable<Integer> idsTable = new Hashtable();
        idsTable.add("Mohamad",11);

        assertEquals(null, idsTable.get("Fadi"));
    }

    @Test public void testHashTableHandleTheCollision() {
        Hashtable<Integer> idsTable = new Hashtable();
        idsTable.add("Mohamad",11);
        idsTable.add("Yaser",22);
        idsTable.add("cdd",33);
        idsTable.add("abc",44);

        String expected =   "6 : [  { Yaser , 22 } --> NULL ]\n" +
                "10 : [  { Mohamad , 11 } -->  { cdd , 33 } --> NULL ]\n" +
                "84 : [  { abc , 44 } --> NULL ]\n";

        assertEquals(expected, idsTable.toString());
    }

    @Test public void testHashTableRetrieveValueFromBucketHasCollision() {
        Hashtable<Integer> idsTable = new Hashtable();
        idsTable.add("Mohamad",11);
        idsTable.add("Yaser",22);
        idsTable.add("cdd",33);
        idsTable.add("abc",44);

        String expected =   "6 : [  { Yaser , 22 } --> NULL ]\n" +
                "10 : [  { Mohamad , 11 } -->  { cdd , 33 } --> NULL ]\n" +
                "84 : [  { abc , 44 } --> NULL ]\n";

        assertEquals(expected, idsTable.toString());

        int output1 = idsTable.get("cdd");
        int output2 = idsTable.get("Mohamad");
        assertEquals(11, output2);
        assertEquals(33, output1);

    }

// RepeatedWord Test code challenge 31
    @Test public void testFindFirstRepeatedWordInNormalCase() {
        String book = "Once upon a time, there was a brave princess who...";
        String expected = "a";
        assertEquals(expected, RepeatedWord.getFirstRepeatedWord(book));
    }

    @Test public void testFindFirstRepeatedWordInEmptyString() {
        String book = "";

        assertNull( RepeatedWord.getFirstRepeatedWord(book));
    }

    @Test public void testFindFirstRepeatedWordInNoStringWithNoRepeatedWords() {
        String book = "Good night..";

        assertNull( RepeatedWord.getFirstRepeatedWord(book));
    }

    @Test public void testFindFirstRepeatedWordInWordWithCommaAndSpaces() {
        String book = "hello, world.. hello everyOne";
        String expected = "hello";
        assertEquals(expected, RepeatedWord.getFirstRepeatedWord(book));
    }

    // tree Intersection
    @Test public void testTreeInterSectionInNormalCase() {
        BinaryTree<Integer> tree1 = new BinaryTree();
        BinaryTree<Integer> tree2 = new BinaryTree();
        TreeIntersection treeIntersection = new TreeIntersection();

        tree1.add(3);
        tree1.add(5);
        tree1.add(7);
        tree1.add(2);
        tree1.add(9);

        tree2.add(3);
        tree2.add(12);
        tree2.add(10);
        tree2.add(5);
        tree2.add(1);
        tree2.add(22);
        List<Integer> expected = new ArrayList<>(); expected.add(3);expected.add(5);
        List<Integer> output = treeIntersection.findCommonValuesInTwoBinaryTrees(tree1, tree2);
        assertArrayEquals(expected.toArray(),output.toArray());


    }

    @Test public void testTreeInterSectionWithFirstTreeIsEmpty() {
        BinaryTree<Integer> tree1 = new BinaryTree();
        BinaryTree<Integer> tree2 = new BinaryTree();
        TreeIntersection treeIntersection = new TreeIntersection();

        tree2.add(3);
        tree2.add(12);
        tree2.add(10);
        tree2.add(5);
        tree2.add(1);
        tree2.add(22);
        List<Integer> expected = new ArrayList<>();
        List<Integer> output = treeIntersection.findCommonValuesInTwoBinaryTrees(tree1, tree2);
        assertArrayEquals(expected.toArray(),output.toArray());


    }

    @Test public void testTreeInterSectionWithSecondTreeIsEmpty() {
        BinaryTree<Integer> tree1 = new BinaryTree();
        BinaryTree<Integer> tree2 = new BinaryTree();
        TreeIntersection treeIntersection = new TreeIntersection();

        tree1.add(3);
        tree1.add(5);
        tree1.add(7);
        tree1.add(2);
        tree1.add(9);


        tree2.add(22);
        List<Integer> expected = new ArrayList<>();
        List<Integer> output = treeIntersection.findCommonValuesInTwoBinaryTrees(tree1, tree2);
        assertArrayEquals(expected.toArray(),output.toArray());


    }

    @Test public void testTreeInterSectionWithAllElementsAreCommon() {
        BinaryTree<Integer> tree1 = new BinaryTree();
        BinaryTree<Integer> tree2 = new BinaryTree();
        TreeIntersection treeIntersection = new TreeIntersection();

        tree1.add(3);
        tree1.add(5);
        tree1.add(7);
        tree1.add(2);
        tree1.add(9);

        tree2.add(3);
        tree2.add(5);
        tree2.add(7);
        tree2.add(2);
        tree2.add(9);
        List<Integer> expected = new ArrayList<>(); expected.add(3);expected.add(5);expected.add(7);expected.add(2);expected.add(9);
        List<Integer> output = treeIntersection.findCommonValuesInTwoBinaryTrees(tree1, tree2);
        assertArrayEquals(expected.toArray(),output.toArray());


    }

    @Test public void testTreeInterSectionWithNoCommonValues() {
        BinaryTree<Integer> tree1 = new BinaryTree();
        BinaryTree<Integer> tree2 = new BinaryTree();
        TreeIntersection treeIntersection = new TreeIntersection();

        tree1.add(3);
        tree1.add(5);
        tree1.add(7);
        tree1.add(2);
        tree1.add(9);

        tree2.add(1);
        tree2.add(10);
        tree2.add(15);

        List<Integer> expected = new ArrayList<>();
        List<Integer> output = treeIntersection.findCommonValuesInTwoBinaryTrees(tree1, tree2);
        assertArrayEquals(expected.toArray(),output.toArray());


    }

    // code challenge 33
    @Test public void testLeftJoinInNormalCase() {
        Hashtable hash1 = new Hashtable();
        Hashtable hash2 = new Hashtable();

        hash1.add("found","enamored");
        hash1.add("wrath","anger");
        hash1.add("diligent","employed");
        hash1.add("outift","guard");
        hash1.add("guide","usher");

        hash2.add("found","averse");
        hash2.add("wrath","delight");
        hash2.add("diligent","idle");
        hash2.add("flow","jam");
        hash2.add("guide","follow");
        String[][] entries = {{"found","enamored","averse"},{"guide","usher","follow"}, {"outift", "guard", null}, {"wrath", "anger", "delight"}, {"diligent", "employed", "idle"}};
        List<List<String>> entries2 = Arrays.stream(entries).map(e-> Arrays.stream(e).collect(Collectors.toList())).collect(Collectors.toList());
        assertArrayEquals(entries2.toArray(),hash1.leftJoin(hash2).toArray());
    }

    @Test public void testLeftJoinWithSecondHashtableIsEmpty() {
        Hashtable hash1 = new Hashtable();
        Hashtable hash2 = new Hashtable();

        hash1.add("found","enamored");
        hash1.add("wrath","anger");
        hash1.add("diligent","employed");
        hash1.add("outift","guard");
        hash1.add("guide","usher");


        String[][] entries = {{"found","enamored",null},{"guide","usher",null}, {"outift", "guard", null}, {"wrath", "anger", null}, {"diligent", "employed", null}};
        List<List<String>> entries2 = Arrays.stream(entries).map(e-> Arrays.stream(e).collect(Collectors.toList())).collect(Collectors.toList());
        assertArrayEquals(entries2.toArray(),hash1.leftJoin(hash2).toArray());
    }

    @Test public void testLeftJoinWithFirstHashMapIsEmpty() {
        Hashtable hash1 = new Hashtable();
        Hashtable hash2 = new Hashtable();



        hash2.add("found","averse");
        hash2.add("wrath","delight");
        hash2.add("diligent","idle");
        hash2.add("flow","jam");
        hash2.add("guide","follow");
//        String[][] entries = {{}};
        List<List<String>> entries2 = new ArrayList<>();
        assertArrayEquals(entries2.toArray(),hash1.leftJoin(hash2).toArray());
    }

    @Test public void testLeftJoinWithNoCommonKeys() {
        Hashtable hash1 = new Hashtable();
        Hashtable hash2 = new Hashtable();

        hash1.add("found","enamored");
        hash1.add("wrath","anger");
        hash1.add("diligent","employed");
        hash1.add("outift","guard");
        hash1.add("guide","usher");

        hash2.add("hello","averse");
        hash2.add("who","delight");
        hash2.add("are","idle");

        String[][] entries = {{"found","enamored",null},{"guide","usher",null}, {"outift", "guard", null}, {"wrath", "anger", null}, {"diligent", "employed", null}};
        List<List<String>> entries2 = Arrays.stream(entries).map(e-> Arrays.stream(e).collect(Collectors.toList())).collect(Collectors.toList());
        assertArrayEquals(entries2.toArray(),hash1.leftJoin(hash2).toArray());
    }
}
