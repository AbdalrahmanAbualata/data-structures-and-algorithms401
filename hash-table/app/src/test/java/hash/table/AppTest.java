/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package hash.table;

import org.junit.Test;
import repeatedWord.RepeatedWord;
import treeIntersection.TreeIntersection;
import trees.BinaryTree;

import java.util.ArrayList;
import java.util.List;

import static org.junit.Assert.*;

public class AppTest {
    @Test public void appHasAGreeting() {
        App classUnderTest = new App();
        assertNotNull("app should have a greeting", classUnderTest.getGreeting());
    }

    @Test public void testHashTableAddingKeyValue() {
        Hashtable<Integer> idsTable = new Hashtable();
        idsTable.add("Mohammad",11);
        boolean output = idsTable.contains("Mohammad");
        assertTrue(output);
    }

    @Test public void testHashTableRetrievingValueBasedOnKey() {
        Hashtable<Integer> idsTable = new Hashtable();
        idsTable.add("Mohammad",11);
        int output = idsTable.get("Mohammad");
        assertEquals(11, output);
    }

    @Test public void testHashTableRetrievingNullForNotExistKey() {
        Hashtable<Integer> idsTable = new Hashtable();
        idsTable.add("Mohamad",11);

        assertEquals(null, idsTable.get("Fadi"));
    }

    @Test public void testHashTableHandleTheCollision() {
        Hashtable<Integer> idsTable = new Hashtable();
        idsTable.add("Mohamad",11);
        idsTable.add("Yaser",22);
        idsTable.add("cdd",33);
        idsTable.add("abc",44);

        String expected =   "6 : [  { Yaser , 22 } --> NULL ]\n" +
                "10 : [  { Mohamad , 11 } -->  { cdd , 33 } --> NULL ]\n" +
                "84 : [  { abc , 44 } --> NULL ]\n";

        assertEquals(expected, idsTable.toString());
    }

    @Test public void testHashTableRetrieveValueFromBucketHasCollision() {
        Hashtable<Integer> idsTable = new Hashtable();
        idsTable.add("Mohamad",11);
        idsTable.add("Yaser",22);
        idsTable.add("cdd",33);
        idsTable.add("abc",44);

        String expected =   "6 : [  { Yaser , 22 } --> NULL ]\n" +
                "10 : [  { Mohamad , 11 } -->  { cdd , 33 } --> NULL ]\n" +
                "84 : [  { abc , 44 } --> NULL ]\n";

        assertEquals(expected, idsTable.toString());

        int output1 = idsTable.get("cdd");
        int output2 = idsTable.get("Mohamad");
        assertEquals(11, output2);
        assertEquals(33, output1);

    }

// RepeatedWord Test code challenge 31
    @Test public void testFindFirstRepeatedWordInNormalCase() {
        String book = "Once upon a time, there was a brave princess who...";
        String expected = "a";
        assertEquals(expected, RepeatedWord.getFirstRepeatedWord(book));
    }

    @Test public void testFindFirstRepeatedWordInEmptyString() {
        String book = "";

        assertNull( RepeatedWord.getFirstRepeatedWord(book));
    }

    @Test public void testFindFirstRepeatedWordInNoStringWithNoRepeatedWords() {
        String book = "Good night..";

        assertNull( RepeatedWord.getFirstRepeatedWord(book));
    }

    @Test public void testFindFirstRepeatedWordInWordWithCommaAndSpaces() {
        String book = "hello, world.. hello everyOne";
        String expected = "hello";
        assertEquals(expected, RepeatedWord.getFirstRepeatedWord(book));
    }

    // tree Intersection
    @Test public void testTreeInterSectionInNormalCase() {
        BinaryTree<Integer> tree1 = new BinaryTree();
        BinaryTree<Integer> tree2 = new BinaryTree();
        TreeIntersection treeIntersection = new TreeIntersection();

        tree1.add(3);
        tree1.add(5);
        tree1.add(7);
        tree1.add(2);
        tree1.add(9);

        tree2.add(3);
        tree2.add(12);
        tree2.add(10);
        tree2.add(5);
        tree2.add(1);
        tree2.add(22);
        List<Integer> expected = new ArrayList<>(); expected.add(3);expected.add(5);
        List<Integer> output = treeIntersection.findCommonValuesInTwoBinaryTrees(tree1, tree2);
        assertArrayEquals(expected.toArray(),output.toArray());


    }

    @Test public void testTreeInterSectionWithFirstTreeIsEmpty() {
        BinaryTree<Integer> tree1 = new BinaryTree();
        BinaryTree<Integer> tree2 = new BinaryTree();
        TreeIntersection treeIntersection = new TreeIntersection();

        tree2.add(3);
        tree2.add(12);
        tree2.add(10);
        tree2.add(5);
        tree2.add(1);
        tree2.add(22);
        List<Integer> expected = new ArrayList<>();
        List<Integer> output = treeIntersection.findCommonValuesInTwoBinaryTrees(tree1, tree2);
        assertArrayEquals(expected.toArray(),output.toArray());


    }

    @Test public void testTreeInterSectionWithSecondTreeIsEmpty() {
        BinaryTree<Integer> tree1 = new BinaryTree();
        BinaryTree<Integer> tree2 = new BinaryTree();
        TreeIntersection treeIntersection = new TreeIntersection();

        tree1.add(3);
        tree1.add(5);
        tree1.add(7);
        tree1.add(2);
        tree1.add(9);


        tree2.add(22);
        List<Integer> expected = new ArrayList<>();
        List<Integer> output = treeIntersection.findCommonValuesInTwoBinaryTrees(tree1, tree2);
        assertArrayEquals(expected.toArray(),output.toArray());


    }

    @Test public void testTreeInterSectionWithAllElementsAreCommon() {
        BinaryTree<Integer> tree1 = new BinaryTree();
        BinaryTree<Integer> tree2 = new BinaryTree();
        TreeIntersection treeIntersection = new TreeIntersection();

        tree1.add(3);
        tree1.add(5);
        tree1.add(7);
        tree1.add(2);
        tree1.add(9);

        tree2.add(3);
        tree2.add(5);
        tree2.add(7);
        tree2.add(2);
        tree2.add(9);
        List<Integer> expected = new ArrayList<>(); expected.add(3);expected.add(5);expected.add(7);expected.add(2);expected.add(9);
        List<Integer> output = treeIntersection.findCommonValuesInTwoBinaryTrees(tree1, tree2);
        assertArrayEquals(expected.toArray(),output.toArray());


    }

    @Test public void testTreeInterSectionWithNoCommonValues() {
        BinaryTree<Integer> tree1 = new BinaryTree();
        BinaryTree<Integer> tree2 = new BinaryTree();
        TreeIntersection treeIntersection = new TreeIntersection();

        tree1.add(3);
        tree1.add(5);
        tree1.add(7);
        tree1.add(2);
        tree1.add(9);

        tree2.add(1);
        tree2.add(10);
        tree2.add(15);

        List<Integer> expected = new ArrayList<>();
        List<Integer> output = treeIntersection.findCommonValuesInTwoBinaryTrees(tree1, tree2);
        assertArrayEquals(expected.toArray(),output.toArray());


    }
}
